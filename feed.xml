<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/SylverQG/Blogs</id><title>RSS feed of SylverQG's Blogs</title><updated>2025-10-21T12:33:09.796182+00:00</updated><author><name>SylverQG</name><email>doublc_qluv@163.com</email></author><link href="https://github.com/SylverQG/Blogs"/><link href="https://raw.githubusercontent.com/SylverQG/Blogs/master/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><entry><id>https://github.com/SylverQG/Blogs/issues/10</id><title>LLM</title><updated>2025-10-21T12:33:10.846420+00:00</updated><content type="html"><![CDATA[<h1>快速入门RAG</h1>
<p>来源：王海文</p>
<h2>0.安装依赖库</h2>
<pre><code class="language-python">%pip install -U langchain_community tiktoken langchain_openai chromadb langchain langchain_core
%pip install sentence_transformers
%pip install huggingface_hub
%pip install ipywidgets
%pip install unstructured
%pip install sentencepiece bs4
</code></pre>
<h2>1.加载文档</h2>
<pre><code class="language-python">from langchain_community.document_loaders import WebBaseLoader

url = &quot;https://techdiylife.github.io/blog/202401/240327-ollama-20question.html&quot;
loader = WebBaseLoader(
    web_paths=[url],
    requests_kwargs={
        &quot;headers&quot;: {
            &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3&quot;
        }
    }
)
docs = loader.load()
</code></pre>
<h2>2.文本切分</h2>
<pre><code class="language-python">from langchain_text_splitters import RecursiveCharacterTextSplitter
text_splitter = RecursiveCharacterTextSplitter(chunk_size=300, chunk_overlap=50)
split_text = text_splitter.split_documents(docs)
</code></pre>
<h2>3.向量化(Embedding)并存储</h2>
<pre><code class="language-python">%pip install langchain_ollama socksio httpcore[socks]
</code></pre>
<pre><code class="language-python">from langchain_community.embeddings import OllamaEmbeddings
# from langchain_ollama import OllamaEmbeddings
from langchain_chroma import Chroma

# ollama下载embedding模型：https://ollama.ai/ 
# ollama pull mofanke/acge_text_embedding
# ollama pull qwen3-embedding:4b

embedding_model = OllamaEmbeddings(model=&quot;qwen3-embedding:4b&quot;)  # 参数名应为 model 而不是 model_name
vectorstore = Chroma.from_documents(documents=split_text, embedding=embedding_model)
retriever = vectorstore.as_retriever()
print(&quot;向量数据库构建完成&quot;)
</code></pre>
<pre><code>向量数据库构建完成
</code></pre>
<pre><code class="language-bash">/tmp/ipykernel_1796418/1638132037.py:8: LangChainDeprecationWarning: The class `OllamaEmbeddings` was deprecated in LangChain 0.3.1 and will be removed in 1.0.0. An updated version of the class exists in the `langchain-ollama package and should be used instead. To use it run `pip install -U `langchain-ollama` and import as `from `langchain_ollama import OllamaEmbeddings``.
  embedding_model = OllamaEmbeddings(model=&quot;qwen3-embedding:4b&quot;)  # 参数名应为 model 而不是 model_name
向量数据库构建完成
</code></pre>
<h2>4.构建prompt模板</h2>
<pre><code class="language-python">from langchain_core.prompts import ChatPromptTemplate

template = &quot;&quot;&quot;你是一个回答问题的助手。请使用以下检索到的信息来回答问题。如果没有相关的信息，请回答&quot;没有找到相关的信息。&quot;。请用最多三句话来保持回答的简洁性

问题: {question}

背景: {context}

答案:
&quot;&quot;&quot;
prompt = ChatPromptTemplate.from_template(template) 


# 也可以从hub中加载
# from langchain import hub
# prompt = hub.load(&quot;tongshi/prompt_template_ragopenai&quot;)
</code></pre>
<h2>5.初始化LLM</h2>
<pre><code class="language-python"># 在线api
# import os
# from dotenv import load_dotenv
# from langchain_openai import ChatOpenAI

# load_dotenv() # loads contents of the .env file

# llm = ChatOpenAI(
#     openai_api_base=&quot;https://api.openai.com/v1&quot;,
#     openai_api_version=&quot;2020-11-07&quot;,
#     openai_api_key=os.getenv(&quot;OPENAI_API_KEY&quot;)
#     model=&quot;gpt-3.5-turbo&quot;,
# )
# ==============================================

# 本地ollama
from langchain_community.llms import Ollama
llm = Ollama(model=&quot;deepseek-r1:7b&quot;)
# from langchain_ollama import OllamaLLM
# llm = OllamaLLM(model=&quot;deepseek-r1:7b&quot;)
</code></pre>
<pre><code class="language-bash">
/tmp/ipykernel_1796418/3311084766.py:18: LangChainDeprecationWarning: The class `Ollama` was deprecated in LangChain 0.3.1 and will be removed in 1.0.0. An updated version of the class exists in the `langchain-ollama package and should be used instead. To use it run `pip install -U `langchain-ollama` and import as `from `langchain_ollama import OllamaLLM``.
  llm = Ollama(model=&quot;deepseek-r1:7b&quot;)
</code></pre>
<h2>6.构建 RAG Chain</h2>
<pre><code class="language-python">from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnablePassthrough

def format_docs(docs):
    return &quot;\n\n&quot;.join([f&quot;{d.page_content}\n\n&quot; for d in docs])

rag_chain = (
    {&quot;context&quot;:retriever | format_docs, &quot;question&quot;: RunnablePassthrough()}
    | prompt
    | llm
    | StrOutputParser()
)

# RunnablePassthrough():将原始输入传送给下一个节点
</code></pre>
<h2>7.执行查询</h2>
<pre><code class="language-python">result = rag_chain.invoke(&quot;ollama支持哪些模型?&quot;)
print(result)
</code></pre>
<pre><code>ollama支持的模型包括70b、8b等版本，具体取决于下载和配置。instruct标签通常指代中文生成模型，text标签则指代中文推理模型，默认为text-3.5-turbo-instruct。官方支持的详细信息可参考https://ollama.com/library。
</code></pre>
<h2>8.批量测试</h2>
<pre><code class="language-python">test_questions = [
    &quot;ollama支持那些模型?&quot;,
    &quot;Linux系统上,模型下载之后,模型存放在哪里?&quot;,
    &quot;Windows系统上,如何修改默认下载位置?&quot;,
    &quot;Modelfile是什么?&quot;,
    &quot;如何导入safetensors格式的模型?&quot;,
    &quot;有什么webui可用吗?&quot;,
]

for i,q in enumerate(test_questions[:3],start=1):
    print(f&quot;问题 {i} : {q}&quot;)
    print(f&quot;答案 {i} : {rag_chain.invoke(q)}\n&quot;)
</code></pre>
<pre><code>问题 1 : ollama支持那些模型?
答案 1 : Ollama模型库中，70b和8b分别对应Qwen-7B和Qwen-8B模型；instruct是Instruct系列指令模型，text是专门的文本生成模型。

问题 2 : Linux系统上,模型下载之后,模型存放在哪里?
答案 2 : 在 Linux 系统上，默认情况下，下载好的模型会被存放在 `/home/&lt;username&gt;/.ollama/models` 的位置。

问题 3 : Windows系统上,如何修改默认下载位置?
答案 3 : 如何修改下载模型的默认存放目录？  
在 Windows 系统中，可以进入 Documentary 或 Document folder 设置，默认存储位置为 C:\Users\&lt;username&gt;\.ollama\models。打开系统属性，选择“文档”或“更多文件夹”，找到 ollama_models 文件夹并修改其路径。
</code></pre>
<h1>关键技术点</h1>
<h2>1.通过Ollama使用Embeddinng模型</h2>
<pre><code class="language-python">%ollama pull mxbai-embed-large
# 或
%ollama pull mofanke/acge_text_embedding
# 或
%ollama pull qwen3-embedding:4b
from langchain_community.embeddings import OllamaEmbeddings
# from langchain_ollama import OllamaEmbeddings
embedding_model = OllamaEmbeddings(model=&quot;qwen3-embedding:4b&quot;)
</code></pre>
<h2>2.如何通过Ollama使用LLM</h2>
<pre><code class="language-python"># 本地ollama
from langchain_community.llms import Ollama
llm = Ollama(model=&quot;deepseek-r1:7b&quot;)
# llm = Ollama(model=&quot;qwen3&quot;)
</code></pre>
<blockquote>
<p>支持流式输出：</p>
<pre><code>for chunk in llm.stream(&quot;讲个笑话&quot;):
   print(chunk,end=&quot;&quot;,flush=True)
</code></pre>
</blockquote>
<h2>3.将Prompt提示词改为中文</h2>
<pre><code class="language-python">prompt = hub.pull(&quot;rlm/rag-prompt&quot;)
prompt.message[0].prompt.template = &quot;&quot;&quot;你是一个回答问题的助手。请使用以下检索到的信息来回答问题。如果没有相关的信息，请回答&quot;没有找到相关的信息。&quot;。请用最多三句话来保持回答的简洁性

问题: {question}

背景: {context}

答案: &quot;&quot;&quot;
</code></pre>
<p>或者直接用<code>ChatPromptTemplate.from_template()</code>自定义</p>
<h2>4.RAG是如何进行检索的</h2>
<ol>
<li>向量化：使用Embedding模型将文本转换为向量（如 mxbai-embed-large）</li>
<li>相似度计算：使用余弦相似度 (cosine similarity) 向量数据库中查找最接近的文档</li>
<li>返回Top-K：返回最相关的K个文档的上下文</li>
</ol>
<p><code>retriever = vectorstore.as_retriever(search_kwargs={&quot;k&quot;:3}) # 返回前三个结果</code></p>
<h2>5.RAG是如何生成答案的</h2>
<ol>
<li>将用户问题+检索到的上下文 -&gt; 拼接成Prompt</li>
<li>输入给LLM进行推理</li>
<li>LLM仅基于上下文作答，避免进行幻觉</li>
</ol>
<blockquote>
<p>你是一个回答问题的助手。请使用以下检索到的信息来回答问题……</p>
<p>问题: {question}</p>
<p>背景: {context}</p>
<p>答案: &quot;&quot;&quot;</p>
</blockquote>
<h2>6.Runnable 接口</h2>
<p><code>Runnable</code> 是LangChain的抽象接口，它定义了如何运行一个任务，支持统一调用各种组件(LLM， Prompt, Chain, Agent, Parser等)</p>
<h3>核心方法:</h3>
<ul>
<li><code>.invoke(inputs)</code>: 运行一个任务，返回结果</li>
<li><code>.batch(inputs, batch_size=1)</code>: 批量运行任务，返回结果</li>
<li><code>.stream(inputs)</code>: 运行一个任务，返回结果，支持流式输出</li>
<li><code>.bind(**kwargs)</code>: 绑定参数，返回一个新的Runnable对象</li>
<li><code>.ainvoke(inputs)</code>: 异步运行一个任务，返回结果</li>
<li><code>.abatch(inputs, batch_size=1)</code>: 异步批量运行任务，返回结果</li>
</ul>
<h3>组合方式(LCEL)：</h3>
<pre><code class="language-python">chain = prompt | llm | StrOutputParser()
chain.invoke({&quot;topic&quot;: &quot;bears&quot;})
</code></pre>
<h2>7.修改为读取本地文档</h2>
<pre><code class="language-python"># TXT文件
from langchain.document_loaders import TextLoader
loader = TextLoader(&#x27;data/guide.txt&#x27;)
docs = loader.load()

# HTML文件
from langchain.document_loaders import WebBaseLoader
loader = WebBaseLoader(&quot;example.html&quot;)
docs = loader.load()

# PDF文件（需要安装pypdf2）
from langchain.document_loaders import PyPDFLoader
loader = PyPDFLoader(&quot;example.pdf&quot;)
docs = loader.load()

</code></pre>
<h2>8.如何使用HuggingFace的Embedding模型</h2>
<pre><code class="language-python"># from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain_huggingface import HuggingFaceEmbeddings
from langchain_chroma import Chroma

model_name = &quot;sentence-transformers/all-MiniLM-L6-v2&quot;
model_kwargs = {&quot;device&quot;: &quot;gpu&quot;}
ecode_kwargs = {&quot;normalize_embeddings&quot;: False}
hf_embeddings = HuggingFaceEmbeddings(
    model_name=model_name, 
    model_kwargs=model_kwargs, 
    encode_kwargs=ecode_kwargs)
vector_store = Chorma.from_documents(splits, embedding=hf_embeddings)
</code></pre>
<h2>9.使用HuggingFace的LLM</h2>
<h3>方法一：使用<code>transformers</code>+<code>pipeline</code></h3>
<pre><code class="language-python">from transformers import AutoModelForCausalLm, AutoTokenizer, pipeline
from langchain.llms import HuggingFacePipeline

model_id = &quot;THUDM/chatglm3-6b&quot;
tokenizer = AutoTokenizer.from_pretrained(model_id, trust_remote_code=True)
model = AutoModelForCausalLm.from_pretrained(model_id, trust_remote_code=True, device_map=&quot;auto&quot;)
pipe = pipeline(task=&quot;text-generation&quot;, model=model, tokenizer=tokenizer, new_max_length=512)
llm = HuggingFacePipeline(pipeline=pipe)
</code></pre>
<h3>方法二：使用from_model_id</h3>
<pre><code class="language-python">from langchain_huggingface import HuggingFacePipeLine

llm = HuggingFacePipeLine.from_model_id(
    model_id=&quot;google/gemma2-7b&quot;,
    task=&quot;text-generation&quot;,
    device_map=&quot;auto&quot;,
    model_kwargs={&quot;temperature&quot;: 0.7, &quot;max_length&quot;: 512,&quot;trust_remote_code&quot;: True}
)
</code></pre>
<h1>RAG优化</h1>
<table>
<thead>
<tr>
<th>方向</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>模型升级</td>
<td>使用更大更强的模型</td>
</tr>
<tr>
<td>Embedding优化</td>
<td>使用更高效的Embedding模型</td>
</tr>
<tr>
<td>文本切分</td>
<td>调整chunk_size (256<del>512)、overlap (50</del>100)</td>
</tr>
<tr>
<td>检索策略</td>
<td>修改K 值 (1<del>5)、尝试similarity_threshold (0.7</del>0.9)；过滤低分结果</td>
</tr>
<tr>
<td>Prompt工程</td>
<td>明确指令、限制输出格式、添加示例（few-shot）</td>
</tr>
<tr>
<td>引入Rerank</td>
<td>使用bge-rerank对检索结果重排序</td>
</tr>
</tbody></table>]]></content><link href="https://github.com/SylverQG/Blogs/issues/10"/><category term="LLM"/><published>2025-10-21T12:32:11+00:00</published></entry><entry><id>https://github.com/SylverQG/Blogs/issues/9</id><title>Web Development</title><updated>2025-10-21T12:33:11.271844+00:00</updated><content type="html"><![CDATA[<h1>和风天气API使用指南</h1>
<p><a href="https://dev.qweather.com/">和风天气API</a></p>
<p><code>由腾讯元宝辅助生成</code></p>
<p>基于代码分析，和风天气API目前主要使用JWT认证方式，以下是详细使用说明：</p>
<h2>一、认证方式</h2>
<p>和风天气API采用JWT (JSON Web Token) 认证，替代了传统的API Key方式：</p>
<ol>
<li>
<p><strong>密钥生成</strong>：</p>
<ul>
<li>需要生成Ed25519密钥对（公钥和私钥）</li>
<li>私钥用于签名JWT，公钥需上传到和风天气控制台</li>
</ul>
<pre><code class="language-bash">openssl genpkey -algorithm ED25519 -out ed25519-private.pem \
&amp;&amp; openssl pkey -pubout -in ed25519-private.pem &gt; ed25519-public.pem
</code></pre>
</li>
<li>
<p><strong>JWT生成</strong>：</p>
<pre><code class="language-python">import jwt
import time
from cryptography.hazmat.primitives.serialization import load_pem_private_key

def get_jwt():
    # 加载私钥
    with open(&#x27;ed25519-private.pem&#x27;, &#x27;rb&#x27;) as f:
        private_key = load_pem_private_key(f.read(), password=None)
    
    # 设置payload
    payload = {
        &#x27;iat&#x27;: int(time.time()) - 30,  # 签发时间（提前30秒避免时间误差）
        &#x27;exp&#x27;: int(time.time()) + 900,  # 过期时间（15分钟）
        &#x27;sub&#x27;: PROJECT_ID  # 项目ID
    }
    
    # 设置headers
    headers = {&#x27;kid&#x27;: KEY_ID}  # 密钥ID
    
    # 生成JWT
    encoded_jwt = jwt.encode(payload, private_key, algorithm=&#x27;EdDSA&#x27;, headers=headers)
    return encoded_jwt
</code></pre>
</li>
<li>
<p><strong>使用方式</strong>：</p>
<ul>
<li>在HTTP请求头中添加：<code>Authorization: Bearer {JWT令牌}</code></li>
</ul>
</li>
</ol>
<h2>二、API基本结构</h2>
<ol>
<li>
<p><strong>基础URL</strong>：</p>
<pre><code>https://{API_HOST}/{version}/{endpoint}
</code></pre>
<ul>
<li>API_HOST: 和风天气分配的专属域名（如<code>abcd.as.qweatherapi.com</code>）</li>
<li>version: API版本（如<code>v7</code>）</li>
<li>endpoint: 具体接口（如<code>weather/now</code>）</li>
</ul>
</li>
<li>
<p><strong>请求方法</strong>：</p>
<ul>
<li>主要使用GET请求</li>
</ul>
</li>
<li>
<p><strong>请求参数</strong>：</p>
<ul>
<li>通过URL查询字符串传递</li>
<li>必需参数：location（城市ID或经纬度）</li>
<li>可选参数：lang（语言）、number（结果数量）等</li>
</ul>
</li>
</ol>
<h2>三、常用接口</h2>
<ol>
<li>
<p><strong>城市查询接口</strong>：</p>
<pre><code class="language-python">def get_city_code(city, jwt_token):
    url = f&quot;https://{API_HOST}/geo/v2/city/lookup?location={city}&amp;number=1&amp;lang=zh&quot;
    headers = {&#x27;Authorization&#x27;: f&#x27;Bearer {jwt_token}&#x27;}
    r = requests.get(url, headers=headers)
    data = r.json()
    if data.get(&quot;code&quot;) == &quot;200&quot; and data.get(&quot;location&quot;):
        return data[&quot;location&quot;][0][&quot;id&quot;]  # 返回城市ID
    return None
</code></pre>
</li>
<li>
<p><strong>天气查询接口</strong>：</p>
<pre><code class="language-python">def get_weather(city_id, jwt_token):
    url = f&quot;https://{API_HOST}/v7/weather/now?location={city_id}&amp;lang=zh&quot;
    headers = {&#x27;Authorization&#x27;: f&#x27;Bearer {jwt_token}&#x27;}
    r = requests.get(url, headers=headers)
    data = r.json()
    if data.get(&quot;code&quot;) == &quot;200&quot; and data.get(&quot;now&quot;):
        return data[&quot;now&quot;]  # 返回天气数据
    return None
</code></pre>
</li>
</ol>
<h2>四、响应处理</h2>
<p>API返回JSON格式数据，包含以下主要字段：</p>
<ul>
<li><code>code</code>: 响应状态码（200表示成功）</li>
<li><code>location</code>: 位置信息（城市查询接口返回）</li>
<li><code>now</code>: 实时天气数据（天气查询接口返回）</li>
</ul>
<p>天气数据字段说明：</p>
<ul>
<li><code>temp</code>: 温度</li>
<li><code>text</code>: 天气状况</li>
<li><code>windDir</code>: 风向</li>
<li><code>windScale</code>: 风力</li>
<li><code>humidity</code>: 湿度</li>
<li><code>icon</code>: 天气图标代码</li>
</ul>
<h2>五、完整示例流程</h2>
<ol>
<li>生成JWT令牌</li>
<li>使用城市名称获取城市ID</li>
<li>使用城市ID获取天气信息</li>
<li>解析并展示天气数据</li>
</ol>
<pre><code class="language-python"># 完整流程示例
jwt_token = get_jwt()
city = &quot;西安&quot;
city_id = get_city_code(city, jwt_token)
weather = get_weather(city_id, jwt_token)

if weather:
    print(f&quot;{city}的天气信息:&quot;)
    print(f&quot;温度: {weather.get(&#x27;temp&#x27;, &#x27;未知&#x27;)}°C&quot;)
    print(f&quot;天气: {weather.get(&#x27;text&#x27;, &#x27;未知&#x27;)}&quot;)
    print(f&quot;风向: {weather.get(&#x27;windDir&#x27;, &#x27;未知&#x27;)}&quot;)
    print(f&quot;风力: {weather.get(&#x27;windScale&#x27;, &#x27;未知&#x27;)}级&quot;)
    print(f&quot;湿度: {weather.get(&#x27;humidity&#x27;, &#x27;未知&#x27;)}%&quot;)
</code></pre>
<h2>六、注意事项</h2>
<ol>
<li>JWT令牌有效期为15分钟，过期后需重新生成</li>
<li>确保私钥安全存储，不要泄露</li>
<li>公钥需上传到和风天气控制台</li>
<li>城市查询接口返回的城市ID是获取天气的关键</li>
<li>遇到错误时，检查API_HOST、PROJECT_ID和KEY_ID是否正确</li>
<li>使用<code>requests</code>库时，添加异常处理确保程序稳定性</li>
</ol>
<h2>七、图</h2>
<img width="373" height="198" alt="Image" src="https://github.com/user-attachments/assets/f047b8ae-7e31-4b16-93b0-2a8ed05cc2a0" />
<h2>八、代码</h2>
<h3><code>weather_widget.py</code></h3>
<pre><code class="language-python">import jwt
import requests
import os
import time

from flask import Flask, jsonify, request
from flask_cors import CORS 

from cryptography.hazmat.primitives.serialization import load_pem_private_key
from cryptography.hazmat.backends import default_backend

app = Flask(__name__)
CORS(app) # CORS 跨域请求支持
# 配置信息
API_HOST = &quot;&quot; # https://console.qweather.com/setting?lang=zh
PROJECT_ID = &quot;&quot; # 项目ID
KEY_ID = &quot;&quot; # 凭据ID
PRIVATE_KEY_PATH = os.path.join(os.path.dirname(__file__), &#x27;ed25519-private.pem&#x27;)

def get_jwt():
    &quot;&quot;&quot;生成JWT令牌&quot;&quot;&quot;
    with open(PRIVATE_KEY_PATH, &#x27;rb&#x27;) as f:
        private_key = load_pem_private_key(f.read(), password=None, backend=default_backend())

    payload = {
        &#x27;iat&#x27;: int(time.time()) - 30,
        &#x27;exp&#x27;: int(time.time()) + 900,
        &#x27;sub&#x27;: PROJECT_ID
    }
    headers = {&#x27;kid&#x27;: KEY_ID}
    
    return jwt.encode(payload, private_key, algorithm=&#x27;EdDSA&#x27;, headers=headers)

def get_city_code(city, jwt_token):
    &quot;&quot;&quot;获取城市代码&quot;&quot;&quot;
    url = f&quot;https://{API_HOST}/geo/v2/city/lookup?location={city}&amp;number=1&amp;lang=zh&quot;
    headers = {&#x27;Authorization&#x27;: f&#x27;Bearer {jwt_token}&#x27;}
    
    try:
        r = requests.get(url, headers=headers)
        r.raise_for_status()
        data = r.json()
        if data.get(&quot;code&quot;) == &quot;200&quot; and data.get(&quot;location&quot;):
            return data[&quot;location&quot;][0][&quot;id&quot;]
    except Exception as e:
        app.logger.error(f&quot;获取城市代码失败: {e}&quot;)
    return None

def get_weather(city_id, jwt_token):
    &quot;&quot;&quot;获取天气信息&quot;&quot;&quot;
    url = f&quot;https://{API_HOST}/v7/weather/now?location={city_id}&amp;lang=zh&quot;
    headers = {&#x27;Authorization&#x27;: f&#x27;Bearer {jwt_token}&#x27;}
    
    try:
        r = requests.get(url, headers=headers)
        r.raise_for_status()
        data = r.json()
        if data.get(&quot;code&quot;) == &quot;200&quot; and data.get(&quot;now&quot;):
            return data[&quot;now&quot;]
    except Exception as e:
        app.logger.error(f&quot;获取天气失败: {e}&quot;)
    return None

@app.route(&#x27;/weather&#x27;, methods=[&#x27;GET&#x27;])
def weather():
    &quot;&quot;&quot;天气API端点&quot;&quot;&quot;
    city = request.args.get(&#x27;city&#x27;, &#x27;北京&#x27;)
    
    jwt_token = get_jwt()
    if not jwt_token:
        return jsonify({&quot;error&quot;: &quot;JWT生成失败&quot;}), 500
    
    city_id = get_city_code(city, jwt_token)
    if not city_id:
        return jsonify({&quot;error&quot;: f&quot;找不到城市: {city}&quot;}), 404
    
    weather_data = get_weather(city_id, jwt_token)
    if not weather_data:
        return jsonify({&quot;error&quot;: &quot;天气数据获取失败&quot;}), 500
    
    return jsonify({
        &quot;city&quot;: city,
        &quot;temperature&quot;: weather_data.get(&#x27;temp&#x27;, &#x27;N/A&#x27;),
        &quot;condition&quot;: weather_data.get(&#x27;text&#x27;, &#x27;N/A&#x27;),
        &quot;windDir&quot;: weather_data.get(&#x27;windDir&#x27;, &#x27;N/A&#x27;),
        &quot;windScale&quot;: weather_data.get(&#x27;windScale&#x27;, &#x27;N/A&#x27;),
        &quot;humidity&quot;: weather_data.get(&#x27;humidity&#x27;, &#x27;N/A&#x27;),
        &quot;icon&quot;: weather_data.get(&#x27;icon&#x27;, &#x27;100&#x27;)
    })

if __name__ == &#x27;__main__&#x27;:
    app.run(host=&#x27;0.0.0.0&#x27;, port=5000, debug=True)
</code></pre>
<h3><code>weather.html</code></h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;天气小组件&lt;/title&gt;
    &lt;style&gt;
        .weather-widget { font-family: Arial, sans-serif; background: rgba(255,255,255,0.9); padding: 16px; border-radius: 24px; font-size: 14px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); width: 280px; margin: 20px auto; }
        .weather-form { display: flex; align-items: center; gap: 8px; margin-bottom: 12px; }
        .weather-form input { padding: 8px 12px; border: 1px solid #e0e0e0; border-radius: 16px; flex-grow: 1; }
        .weather-form button { padding: 8px 16px; background: #4285f4; color: white; border: none; border-radius: 16px; cursor: pointer; }
        .weather-info { display: flex; align-items: center; gap: 12px; }
        .weather-icon { font-size: 32px; min-width: 40px; text-align: center; }
        .weather-details { line-height: 1.5; }
        .temperature { font-size: 24px; font-weight: bold; }
        .condition { font-size: 16px; }
        .wind-humidity { font-size: 12px; color: #666; }
    &lt;/style&gt;
    &lt;link href=&quot;https://cdn.jsdelivr.net/npm/qweather-icons@1.7.0/font/qweather-icons.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;weather-widget&quot;&gt;
        &lt;div class=&quot;weather-form&quot;&gt;
            &lt;input type=&quot;text&quot; id=&quot;city-input&quot; placeholder=&quot;输入城市名&quot; value=&quot;西安&quot;&gt;
            &lt;button id=&quot;get-weather&quot;&gt;查询&lt;/button&gt;
        &lt;/div&gt;
        &lt;div class=&quot;weather-info&quot; id=&quot;weather-container&quot;&gt;
            &lt;div class=&quot;weather-icon&quot;&gt;&lt;i class=&quot;qi-999&quot; id=&quot;weather-icon&quot;&gt;&lt;/i&gt;&lt;/div&gt;
            &lt;div class=&quot;weather-details&quot;&gt;
                &lt;div class=&quot;temperature&quot; id=&quot;temperature&quot;&gt;--°C&lt;/div&gt;
                &lt;div class=&quot;condition&quot; id=&quot;condition&quot;&gt;加载中...&lt;/div&gt;
                &lt;div class=&quot;wind-humidity&quot;&gt;
                    &lt;span id=&quot;wind&quot;&gt;风向: --&lt;/span&gt; | &lt;span id=&quot;humidity&quot;&gt;湿度: --%&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        document.getElementById(&#x27;get-weather&#x27;).addEventListener(&#x27;click&#x27;, fetchWeather);
        window.addEventListener(&#x27;DOMContentLoaded&#x27;, fetchWeather);
        
        async function fetchWeather() {
            const city = document.getElementById(&#x27;city-input&#x27;).value;
            const container = document.getElementById(&#x27;weather-container&#x27;);
            const originalHTML = container.innerHTML;
            
            container.innerHTML = &#x27;&lt;div style=&quot;text-align:center;padding:10px&quot;&gt;加载中...&lt;/div&gt;&#x27;;
            
            try {
                const response = await fetch(`http://127.0.0.1:5000/weather?city=${encodeURIComponent(city)}`);
                const text = await response.text();
                const data = JSON.parse(text);
                
                if (data.error) {
                    container.innerHTML = `&lt;div style=&quot;color:red;text-align:center&quot;&gt;${data.error}&lt;/div&gt;`;
                    return;
                }
                
                if (!data.temperature || !data.condition || !data.windDir || !data.windScale || !data.humidity || !data.icon) {
                    container.innerHTML = &#x27;&lt;div style=&quot;color:red;text-align:center&quot;&gt;数据不完整: 缺少必要字段&lt;/div&gt;&#x27;;
                    return;
                }
                
                container.innerHTML = originalHTML;
                document.getElementById(&#x27;weather-icon&#x27;).className = `qi-${data.icon}`;
                document.getElementById(&#x27;temperature&#x27;).textContent = `${data.temperature}°C`;
                document.getElementById(&#x27;condition&#x27;).textContent = data.condition;
                document.getElementById(&#x27;wind&#x27;).textContent = `风向: ${data.windDir} ${data.windScale}级`;
                document.getElementById(&#x27;humidity&#x27;).textContent = `湿度: ${data.humidity}%`;
                
            } catch (error) {
                console.error(&#x27;请求错误:&#x27;, error);
                container.innerHTML = `&lt;div style=&quot;color:red;text-align:center&quot;&gt;${error.name === &#x27;SyntaxError&#x27; ? &#x27;数据格式错误&#x27; : &#x27;网络请求失败&#x27;}: ${error.message}&lt;/div&gt;`;
            }
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content><link href="https://github.com/SylverQG/Blogs/issues/9"/><category term="Python"/><category term="Web"/><published>2025-08-04T16:41:43+00:00</published></entry><entry><id>https://github.com/SylverQG/Blogs/issues/8</id><title>Update Note</title><updated>2025-10-21T12:33:11.778444+00:00</updated><content type="html"><![CDATA[<p>我更新了一下Action里面需要的版本，似乎又make了，因为我重新看了一下仓库issues的更新的提示<a href="https://github.com/yihong0618/gitblog/issues/177">https://github.com/yihong0618/gitblog/issues/177</a>需要把Backup文件夹<a href="https://github.com/SylverQG/Blogs/commit/46b48b5f693df83812deef9d5abbd857ce963b25">删除</a>。</p>
<p>再次复制一下整个的<a href="https://github.com/SylverQG/Blogs/blob/main/.github/workflows/generate_readme.yml"><code>yml</code></a></p>
<pre><code class="language-yml">name: Generate README

on:
  issues:
    types: [opened, edited]
  issue_comment:
    types: [created, edited]
  push:
    branches:
      - main
    paths:
      - main.py

env:
  GITHUB_NAME: SylverQG
  GITHUB_EMAIL: doublc_qluv@163.com

jobs:
  sync:
    name: Generate README
    runs-on: ubuntu-latest
    if: github.repository_owner_id == github.event.issue.user.id || github.event_name == &#x27;push&#x27;
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: 3.13
          cache: pip
          cache-dependency-path: &quot;requirements.txt&quot;
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m venv venv
          source venv/bin/activate
          pip install -r requirements.txt
      
      - name: Generate new md
        run: |
          source venv/bin/activate
          python main.py ${{ secrets.G_T }} ${{ github.repository }} --issue_number &#x27;${{ github.event.issue.number }}&#x27;

      - name: Push README
        run: |
          git config --local user.email &quot;${{ env.GITHUB_EMAIL }}&quot;
          git config --local user.name &quot;${{ env.GITHUB_NAME }}&quot;
          git add BACKUP/*.md
          git commit -a -m &#x27;update new blog&#x27; || echo &quot;nothing to commit&quot;
          git push || echo &quot;nothing to push&quot;
</code></pre>
]]></content><link href="https://github.com/SylverQG/Blogs/issues/8"/><category term="filed"/><published>2025-08-02T10:37:49+00:00</published></entry><entry><id>https://github.com/SylverQG/Blogs/issues/7</id><title>加速世界</title><updated>2025-10-21T12:33:12.219319+00:00</updated><content type="html"><![CDATA[<h1>GitHub 加速镜像</h1>
<h2>kgithub</h2>
<p>一个公益加速项目，仅需在 github.com 前加上’k‘即可，若提示访问限制请刷新。</p>
<p>任意 github 的项目，均可在网址前面加上 k 变为 kgithub.com 就正常了，如无法使用大概率使用的是国外 IP 访问呢，该服务必须使用国内 ip 访问。</p>
<p>如：github.com/XIU2/UserScript 将链接更换后
<a href="https://github.com/X/UserScript">https://github.com/X/UserScript</a>
<a href="https://kgithub.com/X/UserScript">https://kgithub.com/X/UserScript</a></p>
<h2>github.hscsec.cn</h2>
<p>一个国内加速项目，只需要把 github.com 替换为 github.hscsec.cn 就可以解决访问问题。</p>
<p>如：github.com/X/UserScript 将链接更换后
<a href="https://github.com/X/UserScript">https://github.com/X/UserScript</a>
<a href="https://github.hscsec.cn/X/UserScript">https://github.hscsec.cn/X/UserScript</a></p>
]]></content><link href="https://github.com/SylverQG/Blogs/issues/7"/><category term="ping"/><category term="GreatWall"/><published>2023-10-27T08:55:00+00:00</published></entry><entry><id>https://github.com/SylverQG/Blogs/issues/6</id><title>math</title><updated>2025-10-21T12:33:12.663185+00:00</updated><content type="html"><![CDATA[<p>考研数学一的高等数学部分的知识速记如下：
函数极限连续：
极限是高等数学的灵魂，函数连续很重要；
极限存在准则，洛必达法则很好用；
函数连续定义，间断点类型要分清。
导数与微分：
导数定义求导数，公式法则要掌握；
微分概念要理解，求导运算别出错。
中值定理：
拉格朗日中值定理，罗尔定理和柯西定理；
三个定理各自的应用，题目类型要分清。
不定积分与定积分：
不定积分换元法，分部积分法要掌握；
定积分定义别出错，原函数存在定理要清楚。
向量代数与空间解析几何：
向量代数别忘记，平面方程和空间直线方程；
空间曲面方程和曲线方程，投影曲线方程要记牢。
多元函数微分学：
多元函数概念要理解，偏导数和全微分要掌握；
多元函数极值和最值，条件极值要会做。
多元函数积分学：
多元函数积分定义，格林公式、斯托克斯公式要掌握；
二次积分和多重积分，选择方法计算别出错。
常微分方程：
常微分方程定义，解法和通解公式要掌握；
变量分离和恰当方程，降阶法要学会运用。
以上是考研数学一高等数学部分的速记口诀，希望对您有所帮助。</p>
<hr />
<p>考研数学一的线性代数部分的知识点很多，以下是一些速记方法：
记住线性代数的基本概念，包括向量、矩阵、线性方程组、特征值、特征向量等。这些基本概念是理解后续知识点的基础。
掌握矩阵的运算，包括矩阵的加法、减法、乘法、转置等。这些运算在实际问题中经常用到，需要熟练掌握。
理解矩阵的行列式和秩的概念，掌握它们的计算方法。行列式和秩是矩阵的重要性质，对于解决线性方程组和特征值等问题非常重要。
掌握向量组的线性相关性和无关性的概念，掌握向量组极大线性无关组的计算方法。这些概念和计算方法是解决线性方程组和特征值等问题的基础。
掌握线性方程组的求解方法，包括克莱姆法则、高斯消元法、矩阵分解法等。这些方法在实际问题中经常用到，需要熟练掌握。
了解特征值和特征向量的概念，掌握特征值的计算方法和特征向量的求解方法。特征值和特征向量是矩阵的重要性质，对于解决线性方程组和相似对角化等问题非常重要。
掌握正交变换的概念和性质，包括正交矩阵的定义和性质、正交变换的性质等。正交变换是解决二次型等问题的基础，需要熟练掌握。
以上是一些考研数学一线性代数部分的速记方法，但这些知识点需要反复练习和巩固才能真正掌握。建议多做一些相关的练习题和模拟题，同时可以参考一些教材和辅导资料，加深对知识点的理解和记忆。</p>
<hr />
<p>考研数学一的概率论部分的知识速记如下：
随机事件：
互斥对立加减功，条件立乘除清；
概逆概百分比，二项分布是核心；
然事件随便用，选择先试不可能。
随机变量及其概率分布：
随机变量注意分布，离散连续不可疏；
离散注意分布律，连续分布看密度；
分布函数两函数，考试只考求分布。
随机变量的数字特征：
期望方差加协方，数学期望定投方；
方差协方别混淆，期望方差均可用；
数字特征都适用，考试只考大期望。
大数定律和中心极限定理：
切比雪夫不等式，强大数律中心极；
切比雪夫考最多，其他三个考选择。
数理统计的基本概念：
总体个体犯错误，统计总体要犯错；
样本容量的定义，样本个体要记清；
样本均值与方差，两个统计别搞混；
总体分布函数好，样本分布函数妙。
参数估计：
点估计与区间估计，矩估计与最大似然估计；
点估计优缺点，区间估计优缺点；
最大似然优缺点，考试只考矩估计。
以上是考研数学一概率论部分的速记口诀，希望对您有所帮助。</p>
]]></content><link href="https://github.com/SylverQG/Blogs/issues/6"/><category term="math"/><published>2023-10-19T14:31:49+00:00</published></entry><entry><id>https://github.com/SylverQG/Blogs/issues/5</id><title>ComputerNet</title><updated>2025-10-21T12:33:13.163724+00:00</updated><content type="html"><![CDATA[<h1>一、概述</h1>
<ol>
<li>
计算机性能<ol>
<li>速率（比特每秒bit/s）：比特（bit）：信息论中<strong>信息量的单位</strong>；网络技术中<strong>速率</strong>指的是<strong>数据的传送速率</strong>也称为<strong>数据率</strong>或<strong>比特率</strong></li>
<li>
带宽（两种不同意义）：<ol>
<li>频域称谓，指信号具有的频带宽度，单位Hz</li>
<li>时域称谓，表示在单位时间内网络中某信道所能通过的“最高数据率”，单位比特每秒（bit/s）；两者本质一样，一条通信链路的“带宽”越宽，传输的“最高数据率”自然越高</li>
</ol>
</li>
<li>吞吐量：单位时间内通过某个网络（或信道、接口）的实际数据量。受网络的带宽或网络的额定速率的限制</li>
<li>时延：时延是指数据（一个报文或分组，甚至是比特）从网络（或链路）的一端传送到另一端所需的时间，有时也成为延迟或迟延</li>
</ol>
</li>
</ol>
<ul>
<li>发送时延（传输时延）：主机或路由器发送数据帧所需要的时间</li>
</ul>
<pre><code class="language-math">   发送时延=\frac{数据帧长度(b)}{发送速率(b/s)}
</code></pre>
<ul>
<li>传播时延：电磁波在信道中传播一定的距离需要花费的时间</li>
</ul>
<pre><code class="language-math">   传输时延=\frac{信道长度(m)}{电磁波在信道上的传播率(m/s)}
</code></pre>
<ul>
<li>处理时延：主机或路由器在收到分组时需要花费一定的时间进行处理</li>
<li>排队时延：结点缓存队列中分组排队所经历的时延（取决于网络当时的通信量）；数据在网络中经历的总时延就是以上四种时延之和</li>
<li>注：对于高速网络，提高的仅仅是数据的发送率不是比特在链路上的传播速率
5. 时延带宽积： $时延带宽积（体积）= 传播时延（长）\times 带宽（截面积）$，以比特为单位的链路长度
6. 往返时间（RTT）：简单来说，就是两倍传播时延（实际上还包括处理时延，排队时延，转发时的发送时延）
7. 利用率：信道利用率 $\rightarrow$ 网络利用率（全网络的信道利用率的加权平均值） $D=\frac{D_0}{1-U}, D_0$表示网络空间时的延时， $D_0$表示网络空闲时时延， $U$为利用率， $D$表示网络当前的时延；可见信道利用率并不是越高越好，当某信道的利用率增大时，该信道引起的时延也就迅速增大。 减少方法是增大线路的带宽</li>
</ul>
<ol start="2">
<li>
计算机网络体系结构<ol>
<li>OSI/RM：开放系统互联参考模型（法律上的国际标准）：简称<code>OSI</code></li>
<li>TCP/IP：事实上的国际标准</li>
<li>协议：为进行网络中的数据交换而建立的规则、标准或约定。三要素：语法（结构和格式），语义（动作），同步（顺序）</li>
<li>
分层的好处<ol>
<li>各层之间是独立的</li>
<li>灵活性好</li>
<li>结构上可分割开</li>
<li>易实现和维护</li>
<li>能促进标准化工作</li>
</ol>
</li>
<li>
五层体系结构<ol>
<li>应用层：通过应用进程（正在运行的程序）间的交互来完成特定网络应用。（如DNS，HTTP，SMTP，FTP）</li>
<li>
运输层：负责向两台主机中进程之间的通信提供的数据传输服务。（复用和分用）<ol>
<li>传输控制协议TCP：提供面向连接的、可靠的数据传输服务，其数据传输单位是报文段</li>
<li>用户数据报协议UDP：提供无连接的、尽最大努力的数据传输服务（不保证可靠性），其数据传输单位是用户数据报</li>
</ol>
</li>
<li>网络层：负责为分组交换网上的不同主机提供通信服务（TCP/IP体系中，分组也叫IP数据报）</li>
<li>数据链路层：将网络层交下来的IP数据报组装成帧，在两个相邻结点（主机和路由器之间或路由器之间）间的链路上传送帧；每一帧包括数据和必要的控制信息</li>
<li>物理层：透明地传送比特流（双绞线、同轴电缆、光缆、无线信道等不在物理层）</li>
</ol>
</li>
</ol>
</li>
<li>
词语<ol>
<li>实体：任何可发送或接受信息的硬件或软件进程</li>
<li>协议：控制两个对等实体（或多个实体）进行通信的规则的集合。（水平的）</li>
<li>在协议控制下，两个对等实体间的通信使得本层能够向上一层提供服务（垂直的）要实现本层协议，还需要使用下面一层所提供的服务</li>
<li>同一系统相邻两层的实体进行交互（即交换信息）的地方，称为服务访问SAP</li>
</ol>
</li>
</ol>
<h1>二、物理层</h1>
<ol>
<li>
基本概念<ul>
<li>机械特性（接口）</li>
<li>电气特性（电压范围）</li>
<li>功能特性（电压的意义）</li>
<li>过程特征（顺序）</li>
</ul>
</li>
<li>
数据通信系统
一个数据通信系统可划分为三大部分，即源系统（发送端、发送方） $\rightarrow$ 传输系统（传输网络） $\rightarrow$ 目的系统（接收端、接收方）<ul>
<li>数据（data）：运送消息的实体</li>
<li>信号（signal）：数据的电气的或电磁的表现</li>
<li>模拟信号或连续信号（analogous）：代表消息的参数的取值是连续的</li>
<li>数字信号或离散信号（digital）：代表消息的参数的取值是离散的</li>
<li>码元（code）：代表不同离散数值的基本波形</li>
</ul>
</li>
<li>
信道的基本概念
信道用来表示向某个方向传送信息的媒体；可以有以下三种基本方式<ol>
<li>单向通信（单工通信）：只能有一个方向的通信而没有反方向的交互（广播）</li>
<li>双向交替通信（半双工通信）：通信的双方都可以发送信息，但不能双方同时发送（当然也就不能同时接收）这种通信方式是一方发送另一方接收，过一段时间后，可以再反过来</li>
<li>双向同时通信（全双工通信）：通信的双方可以同时发送和接收信息</li>
</ol>
</li>
<li>
信道的极限容量<ol>
<li>信道能够通过的频率范围（码间串扰）：加宽频带</li>
<li>信噪比：信号的平均功率的噪声的平均功率之比；常记为 $S/N$，并用分贝(dB)作为度量单位。即： $信噪比(dB)=10\log_{10} (S/N)(dB)$</li>
<li>香农公式：信道的极限信息传输速率 $C=W\log_{2}(1+S/N) (bit/s)$;式中W为信道的带宽（单位Hz），S为信道内所传信号的平均功率，N为信道内部的高斯噪声功率</li>
<li>香农公式表明：信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。只要信息传输速率低于信道的极限传输速率，就一定存在某种方法实现无差错传输</li>
</ol>
</li>
<li>
信道复用技术<ol>
<li>频分复用（FDM）：所有用户在同样的时间占用不同的资源</li>
<li>时分复用（TDM）（同步时分复用）：所有用户在不同的时间用同样的频带宽度；（更有利于数字信号的传输）</li>
<li>以上两种复用方法的优点是技术比较成熟，缺点是不够灵活</li>
<li>统计时分复用（STDM）（异步时分复用）：动态分配时隙；集中器常使用统计时分复用</li>
<li>波分复用：光的频分复用</li>
<li>码分多址（码分多址CDMA）：各用户使用不同的码型，因此各用户之间不会造成干扰。每个站分配的码片序列不仅必须各不相同，并且还必须互相正交（相乘为0，0写为-1，1写为+1）。在使用的系统中是使用为随机序列。</li>
<li>任何一个码片向量和该码片向量自己的规格内积都是 1；</li>
<li>任何一个码片向量和该码片反码的向量自己的规格内积都是 -1；</li>
<li>任何一个码片向量和其他该码片向量自己的规格内积都是 0；</li>
</ol>
</li>
<li>
宽带接入技术<ul>
<li>ADSL（非对称数字用户线）技术：用数字技术对现有模拟电话用户线进行改造。ADSL的极限传输距离取决于数据率和用户线的线经（用户线越细，信号传输时的衰减就越大）</li>
<li>光纤同轴混合网（HFC网）</li>
<li>FTTx技术：光纤到户FTTH</li>
</ul>
</li>
<li>例：假定某信道受奈氏准则限制的最高码元速率为20000码元/元。如果采用振幅调制，把码元的振幅划分为16个不同的等级来传送，那么可以获得多高的数据率（b/s）答： $C = R \ast log_{2}{16} = 20000b/s \ast 4 = 80000b/s $</li>
<li>共有4个站进行CDMA通信。4个站的码片序列为
A. (-1-1-1+1+1-1+1+1)
B. (-1-1+1-1+1+1+1-1)
C. (-1+1-1+1+1+1-1-1)
D. (-1+1-1-1-1-1+1-1)
现在受到这样的码片序列S：(-1+1-3+1-1-3+1+1)。问哪个站发送数据了发送数据的站发送的是0还是1？
解：
$S\cdot A= (+1-1+3+1-1+3+1+1) / 8=1,  A 发送1$
$S\cdot B= (+1-1-3-1-1-3+1-1) / 8=-1, B 发送0$
$S\cdot C= (+1+1+3+1-1-3-1-1) / 8=0,  C 无发送$
$S\cdot D= (+1+1+3-1+1+3+1-1) / 8=1,  D 发送1$</li>
</ol>
]]></content><link href="https://github.com/SylverQG/Blogs/issues/5"/><category term="ComputerNet"/><published>2023-10-06T14:56:13+00:00</published></entry><entry><id>https://github.com/SylverQG/Blogs/issues/4</id><title>DataStructure</title><updated>2025-10-21T12:33:13.635811+00:00</updated><content type="html"><![CDATA[<h1>一、绪论|顺序表</h1>
<ol>
<li>数据元素、数据项以及数据结构三者之间的关系</li>
<li>逻辑结构、存储结构（物理结构）的区分</li>
<li>算法的特征与设计要求</li>
<li>时间复杂度、空间复杂度的理解与计算</li>
<li>线性表的定义与特点</li>
<li>顺序表的定义、特点以及操作</li>
<li>
算法<ol>
<li>顺序表的插入</li>
<li>顺序表的删除</li>
<li>顺序表的合并算法</li>
</ol>
</li>
</ol>
<h1>二、链表|约瑟夫环</h1>
<ol>
<li>链表的特点</li>
<li>链表的定义</li>
<li>为什么要设置头节点</li>
<li>单链表的基本操作（查找、插入、删除、合并、头插法、尾插法）</li>
<li>链表的分类及其特征</li>
<li>约瑟夫环</li>
<li>
算法<ol>
<li>单链表的查找</li>
<li>单链表的插入</li>
<li>单链表的删除</li>
<li>表头插入法建立单链表</li>
<li>表尾插入法建立带头结点的单链表</li>
<li>表尾插入法建立不带头结点的单链表</li>
<li>两个有序单链表的合并</li>
<li>约瑟夫环算法</li>
</ol>
</li>
</ol>
<h1>三、栈|队列</h1>
<ol>
<li>栈、队列的定义与特点</li>
<li>栈、队列的存储结构与基本操作</li>
<li>栈、队列的应用</li>
<li>循环队列</li>
<li>
算法<ol>
<li>
顺序栈<ol>
<li>初始化</li>
<li>元素入栈</li>
</ol>
</li>
<li>
链栈<ol>
<li>初始化</li>
<li>入队</li>
<li>出队列</li>
</ol>
</li>
<li>
循环队列<ol>
<li>初始化</li>
<li>入队</li>
<li>出队</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1>四、串|压缩矩阵</h1>
<ol>
<li>串的基本运算</li>
<li>串的模式匹配、KMP</li>
<li>矩阵的压缩矩阵与三元组</li>
<li>
算法<ol>
<li>
串<ol>
<li>朴素的串匹配算法</li>
<li>模式匹配算法——KMP</li>
<li>KMP模式匹配算法——求next[j]的算法</li>
</ol>
</li>
<li>
数组<ol>
<li>三元组顺序表上的转置</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1>四、树</h1>
<ol>
<li>树的定义和基本术语</li>
<li>二叉树的定义、基本运算、性质以及存储结构</li>
<li>二叉树的遍历（递归算法，非递归算法）</li>
<li>树和森林与二叉树的关系</li>
<li>森林与二叉树的转换及遍历</li>
<li>哈夫曼树的构造、哈夫曼编码</li>
<li>连接线索二叉树</li>
<li>
算法<ol>
<li>
二叉树递归遍历<ol>
<li>先须递归遍历</li>
<li>中序递归遍历</li>
<li>后序递归遍历</li>
</ol>
</li>
<li>
二叉树遍历非递归算法<ol>
<li>先序遍历</li>
<li>中序遍历</li>
</ol>
</li>
<li>
中序线索二叉树<ol>
<li>创建中序线索二叉树</li>
<li>中序线索二叉树上找指定结点的后继</li>
</ol>
</li>
<li>
哈夫曼编码和译码<ol>
<li>哈夫曼编码</li>
<li>哈夫曼译码</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1>五、图的遍历和图的遍历</h1>
<ol>
<li>图的基本术语</li>
<li>图的两种基本存储结构</li>
<li>图的遍历，广度、深度遍历结果的区别</li>
<li>图的应用（拓扑排序、最小生成树、最短路径、关键路径），掌握手动模拟</li>
<li>图的入度、出度计算</li>
<li>关键路径长度计算</li>
<li>
算法<ol>
<li>图的深度优先搜索遍历（DFS）</li>
<li>图的广度优先搜索遍历（BFS）</li>
<li>
最小生成树<ol>
<li>Prim</li>
<li>Kruskal</li>
</ol>
</li>
<li>拓扑排序算法x</li>
<li>
关键路径算法x<ol>
<li>最早发生</li>
<li>最晚发生</li>
<li>输出关键路径、关键活动</li>
</ol>
</li>
<li>
最短路径<ol>
<li>Dijkstra</li>
<li>Floyd</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1>六、索引结构|散列技术</h1>
<ol>
<li>顺序表的查找</li>
<li>索引结构</li>
<li>有序表的查找（折半查找）</li>
<li>索引顺序表的查找</li>
<li>二叉排序树</li>
<li>平衡二叉树</li>
<li>哈希表（又称散列表）掌握开放地址法和拉链法</li>
<li>平均查找长度（ASL、 $ASL_{成功}$、 $ASL_{失败}$）</li>
<li>
算法<ol>
<li>
常规<ol>
<li>无序表的顺序查找</li>
<li>有序表的顺序查找</li>
</ol>
</li>
<li>
二叉排序树<ol>
<li>二叉排序树的插入算法</li>
<li>二叉排序树的查找算法</li>
<li>二叉排序树的操作有多种形式</li>
</ol>
</li>
<li>
平衡二叉树<ol>
<li>
平衡二叉树<ol>
<li>RR</li>
<li>LL</li>
<li>LR</li>
<li>RL</li>
</ol>
</li>
</ol>
</li>
<li>
哈希表<ol>
<li>
构造方法<ol>
<li>直接定址法</li>
<li>数字分析法</li>
<li>平方取中法</li>
<li>折叠法</li>
<li>除留余数法</li>
</ol>
</li>
<li>
冲突处理方法<ol>
<li>开放定址法</li>
<li>链地址法</li>
<li>再哈希法</li>
<li>公共溢出区法</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1>七、缩小规模算法</h1>
<ol>
<li>分治算法（分解、求解、合并）</li>
<li>二分查找</li>
<li>归并排序（二路归并排序、多路归并排序）</li>
<li>交换排序（冒泡排序、快速排序）</li>
<li>动态规划（矩阵连乘、重叠子问题、备忘录方法、图像压缩、最优二叉搜索树）</li>
<li>贪心算法</li>
<li>
算法<ol>
<li>
简单算法<ol>
<li>有序顺序表上的折半查找</li>
<li>直接插入排序</li>
<li>折半插入排序</li>
<li>归并算法</li>
<li>冒泡排序</li>
</ol>
</li>
<li>
动态规划<ol>
<li>矩阵连乘</li>
<li>重叠子问题</li>
<li>备忘录方法</li>
<li>图像压缩</li>
<li>最有二叉搜索树</li>
</ol>
</li>
<li>
贪心算法<ol>
<li>背包问题</li>
<li><code>0-1</code>背包问题</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content><link href="https://github.com/SylverQG/Blogs/issues/4"/><category term="DataStructure"/><published>2023-10-05T14:52:23+00:00</published></entry><entry><id>https://github.com/SylverQG/Blogs/issues/3</id><title>Crypto</title><updated>2025-10-21T12:33:14.090662+00:00</updated><content type="html"><![CDATA[<p>现代密码学目录(仅目录)</p>
<h1>1. 基础</h1>
<h2>1.1 威胁</h2>
<h2>1.2 信息安全模型</h2>
<h2>1.3 密码学基本概念</h2>
<h2>1.4 古典密码</h2>
<h1>2. 流密码</h1>
<h2>2.1 基本概念</h2>
<h2>2.2 线性反馈移位寄存器</h2>
<h2>2.3 线性移位寄存器的一元多项式表达式</h2>
<h2>2.4 m序列的伪随机性</h2>
<h2>2.5 m序列密码的破译</h2>
<h2>2.6 非线性序列</h2>
<h1>3. 分组密码体制</h1>
<h2>3.1 概述</h2>
<h2>3.2 数据加密标准</h2>
<h2>3.3 差分密码分析与线性密码分析</h2>
<h2>3.4 分组密码的运行模式</h2>
<h2>3.5 IDEA</h2>
<h2>3.6 AES|Rijindael</h2>
<h2>3.7 SM4</h2>
<h2>3.8 祖冲之</h2>
<h1>4. 公钥密码</h1>
<h2>4.1 数学知识</h2>
<h2>4.2 基本概念</h2>
<h2>4.3 RSA</h2>
<h2>4.4 背包密码体制</h2>
<h2>4.5 NTRU</h2>
<h2>4.6 椭圆曲线密码体制</h2>
<h2>4.7 SM2椭圆曲线公钥密码加密算法</h2>
<h1>5. 密钥分配与密钥管理</h1>
<h2>5.1 单钥加密体制的密钥分配</h2>
<h2>5.2 公钥加密体制的密钥分配</h2>
<h2>5.3 随机数的产生</h2>
<h2>5.4 秘密分割</h2>
<h1>6. 消息认证与哈希函数</h1>
<h2>6.1 消息认证</h2>
<h2>6.2 哈希函数</h2>
<h2>6.3 MD5</h2>
<h2>6.4 安全哈希算法</h2>
<h2>6.5 HMAC</h2>
<h2>6.6 SM3</h2>
<h1>7. 数字签名和认证协议</h1>
<h2>7.1 基本概念</h2>
<h2>7.2 数字签名标准</h2>
<h2>7.3 其他签名方案</h2>
<h2>7.4 SM2椭圆曲线公钥密码签名算法</h2>
<h2>7.4 认证协议</h2>
<h1>8. 密码协议</h1>
<h2>8.1 基本协议</h2>
<h2>8.2 零知识证明</h2>
<h2>8.3 安全多方计算</h2>
<h1>9. 可证明安全</h1>
<h2>9.1 语义安全的公钥密码体制定义</h2>
<h2>9.2 语义安全的RSA的加密方案</h2>
<h2>9.3 Paillier公钥密码系统</h2>
<h2>9.4 Cramer-Shoup密码系统</h2>
<h2>9.5 RSA-FDH签名方案</h2>
<h2>9.6 BLS短签名方案</h2>
<h2>9.7 基于身份的密码体制</h2>
<h1>10. 网络加密与认证</h1>
<h2>10.1 网络通信加密</h2>
<h2>10.2 Kerberos认证系统</h2>
<h2>10.3 X.509认证业务</h2>
<h2>10.4 PGP</h2>
]]></content><link href="https://github.com/SylverQG/Blogs/issues/3"/><category term="Crypto"/><published>2023-09-21T14:01:39+00:00</published></entry><entry><id>https://github.com/SylverQG/Blogs/issues/2</id><title>how issues go to the md?</title><updated>2025-10-21T12:33:14.541500+00:00</updated><content type="html"><![CDATA[<ol>
<li>
<p>本仓库搭建概况</p>
<ul>
<li>基于 <a href="https://github.com/yihong0618/gitblog/issues/177">https://github.com/yihong0618/gitblog/issues/177</a> 、</li>
<li>加上 <a href="https://github.com/egolearner/paper-note.git">https://github.com/egolearner/paper-note.git</a> 的一些配置(Action自动化), </li>
<li>并更新到较新的<code>ActionFlow</code>版本(当然应该不是最合适的版本，好像还是有<code>Node.js 12 to Node.js 16</code> 的警告)</li>
</ul>
</li>
<li>
<p>搭建过程的一些问题(遇到的，并从issue里总结的)</p>
<ol>
<li>
cookbook依旧是<a href="https://github.com/yihong0618/gitblog/issues/177">https://github.com/yihong0618/gitblog/issues/177</a>中的这些步骤，即<ul>
<li>①生成个人Token，并添加到仓库设置中。</li>
<li>②文件<code>.github/workflows/generate_readme.yml</code>中<code>env</code>项的<code>name</code>和<code>email</code>设置更改为自己的</li>
</ul>
</li>
<li><code>.github/workflows/generate_readme.yml</code>的其他修改如下：即添加注释的地方</li>
</ol>
<pre><code class="language-yml">    name: Generate README
    
    on:
      issues:
        types: [opened, edited]
      issue_comment:
        types: [created, edited]
      push:
        branches:
          - main
        paths:
          - main.py
    
    env:
      GITHUB_NAME: SylverQG
      GITHUB_EMAIL: doublc_qluv@163.com
    
    jobs:
      sync:
        name: Generate README
        runs-on: ubuntu-latest
        if: github.repository_owner_id == github.event.issue.user.id || github.event_name == &#x27;push&#x27;
        steps:
          - name: Checkout
            uses: actions/checkout@v3
          - name: Set up Python
            uses: actions/setup-python@v3
            with:
              python-version: 3.9
              cache: pip
              cache-dependency-path: &quot;requirements.txt&quot;
    
          # - name: Configure pip cache
          #   uses: actions/cache@v2
          #   id: pip-cache
          #   with:
          #     path: venv
          #     key: pip-1-${{ &quot;hashFiles(&#x27;**/requirements.txt&#x27;)&quot; }}
          #     restore-keys: |
          #       pip-
          
          - name: Install dependencies
            run: |
              python -m pip install --upgrade pip
              python -m venv venv
              source venv/bin/activate
              pip install -r requirements.txt
            # if: steps.pip-cache.outputs.cache-hit != &#x27;true&#x27;
          
          - name: Generate new md
            run: |
              source venv/bin/activate
              python main.py ${{ secrets.G_T }} ${{ github.repository }} --issue_number &#x27;${{ github.event.issue.number }}&#x27;
    
          # - name: Push README
          #   uses: github-actions-x/commit@v2.9
          #   with:
          #     github-token: ${{ secrets.G_T }}
          #     commit-message: &quot;UPDATE README&quot;
          #     files: BACKUP/*.md README.md feed.xml
          #     rebase: &#x27;true&#x27;
          #     name: SylverQG 
          #     email: doublc_qluv@163.com
    
          - name: Push README
            run: |
              git config --local user.email &quot;${{ env.GITHUB_EMAIL }}&quot;
              git config --local user.name &quot;${{ env.GITHUB_NAME }}&quot;
              git add BACKUP/*.md
              git commit -a -m &#x27;update new blog&#x27; || echo &quot;nothing to commit&quot;
              git push || echo &quot;nothing to push&quot;
</code></pre>
</li>
<li>
<p>警告详情 <code>actions/checkout@v2</code>,<code>actions/setup-python@v1</code>,<code>actions/cache@v1</code>  update to <code>actions/checkout@v3</code>,<code>actions/setup-python@v2</code>,<code>actions/cache@v2</code> </p>
</li>
</ol>
<pre><code class="language-Warning">Generate README
Node.js 12 actions are deprecated. Please update the following actions to use Node.js 16: actions/setup-python@v2, actions/cache@v2. For more information see: https://github.blog/changelog/2022-09-22-github-actions-all-actions-will-begin-running-on-node16-instead-of-node12/.
</code></pre>
<ol start="4">
<li>错误详情 <code>github-actions-x/commit@v2.6</code> update to v2.9 (the latest)
the error shows:</li>
</ol>
<pre><code class="language-error">Command line: | /usr/bin/git pull --rebase --autostash origin main
Stderr:       | fatal: detected dubious ownership in repository at &#x27;/github/workspace&#x27;
              | To add an exception for this directory, call:
              | 
              | 	git config --global --add safe.directory /github/workspace
</code></pre>
<ol start="5">
<li>错误详情 <code>生成通过但是仓库没有变更</code> ，此时可以重新生成Token，重新添加到仓库的设置中。[这与本地的错误类似，即没有当前仓库的权限]</li>
</ol>
<pre><code class="language-error">remote: Permission to SylverQG/Blogs.git denied to github-actions[bot].
fatal: unable to access &#x27;https://github.com/SylverQG/Blogs/&#x27;: The requested URL returned error: 403
nothing to push
</code></pre>
]]></content><link href="https://github.com/SylverQG/Blogs/issues/2"/><category term="ping"/><category term="filed"/><published>2023-06-15T12:56:55+00:00</published></entry><entry><id>https://github.com/SylverQG/Blogs/issues/1</id><title>A New Try as Restart</title><updated>2025-10-21T12:33:15.001736+00:00</updated><content type="html"><![CDATA[<h1>A New Try</h1>
<p>To make blogs by the issues</p>
<p>To say goodbye to the old world</p>
<p>To put the ping in the e-world</p>
<h1>The new ID/github_repository</h1>
<ul>
<li>
Sylver，即Silver，避免被注册哈哈<ul>
<li>Silver Bullet: 杀狼人的特效武器，万金油，杀手锏，最强杀招，王牌，<code>a simple solution to a complicated problem</code>，</li>
<li>《名侦探柯南》中的两人有此称呼，琴说是赤井秀一，贝尔摩德认为还有江户川柯南</li>
<li>希望我有朝一日可以值此新名</li>
</ul>
</li>
<li>QG，名字大写缩写</li>
</ul>
<h1>put the ping</h1>
<blockquote>
<p>You will die but github long live.</p>
</blockquote>
<p>尝试了很多种类的github博客形式。、</p>
<ul>
<li>
从本地编译上传的形式<ul>
<li>Hexo <a href="https://github.com/iissnan/hexo-theme-next">主题 NexT.Pisces</a></li>
<li>vuepress2 <a href="https://theme-hope.vuejs.press/zh/">主题 hope</a></li>
</ul>
</li>
<li>
读取<code>issue</code>并有一套漂亮前端的形式<ul>
<li>二次元的 <a href="https://github.com/chanshiyucx/aurora">aurora</a> <del>可惜没有高频维护，我自己还没学过[TypeScript 或者 JavaScript]</del></li>
<li>
简洁的 <a href="https://github.com/lesnolie/Marverick">Marverick</a> <del>本来想弄这个的，但好像失败了。那就考虑不如直接找到化繁为简</del><ul>
<li><a href="https://github.com/AlanDecode/Maverick/">Marverick</a> + <a href="https://github.com/yihong0618/gitblog">gitblog</a></li>
</ul>
</li>
</ul>
</li>
<li>终于本仓库暂时使用 <a href="https://github.com/yihong0618/gitblog">gitblog</a></li>
</ul>
<h1>Plan</h1>
<p>之后考虑从<a href="https://github.com/doublc-qluv">原来的GitHub仓库</a>一点一点搬运，<del>还是也把那个<a href="https://doublc-qluv.github.io/">github.io</a>也搞成这样</del>，或者再找个好看的主题也不是不行</p>
]]></content><link href="https://github.com/SylverQG/Blogs/issues/1"/><category term="ping"/><published>2023-06-13T14:09:48+00:00</published></entry></feed>